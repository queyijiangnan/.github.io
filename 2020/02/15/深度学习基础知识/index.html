<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>深度学习基础知识 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一、为什么深层神经网络难以训练？1、梯度消失。梯度消失是指通过隐藏层从后向前看，梯度会变得越来越小，说明前面层的学习会显著慢于后面层的学习，所以学习会卡住 ，除非梯度变大。  梯度消失的原因：学习率的大小，网络参数的初始化，激活函数的边缘效应等。在深层神经网络中，每一个神经元计算得到的梯度都会传递 给前一层，较浅层的神经元接收到的梯度受到之前所有层梯度的影响。如果计算得到的梯度值非常小，随着层数增">
<meta property="og:type" content="article">
<meta property="og:title" content="深度学习基础知识">
<meta property="og:url" content="http://yoursite.com/2020/02/15/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="一、为什么深层神经网络难以训练？1、梯度消失。梯度消失是指通过隐藏层从后向前看，梯度会变得越来越小，说明前面层的学习会显著慢于后面层的学习，所以学习会卡住 ，除非梯度变大。  梯度消失的原因：学习率的大小，网络参数的初始化，激活函数的边缘效应等。在深层神经网络中，每一个神经元计算得到的梯度都会传递 给前一层，较浅层的神经元接收到的梯度受到之前所有层梯度的影响。如果计算得到的梯度值非常小，随着层数增">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-02-14T17:05:28.000Z">
<meta property="article:modified_time" content="2020-02-15T11:26:36.853Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-深度学习基础知识" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/15/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="article-date">
  <time datetime="2020-02-14T17:05:28.000Z" itemprop="datePublished">2020-02-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      深度学习基础知识
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、为什么深层神经网络难以训练？"><a href="#一、为什么深层神经网络难以训练？" class="headerlink" title="一、为什么深层神经网络难以训练？"></a>一、为什么深层神经网络难以训练？</h2><pre><code>1、梯度消失。梯度消失是指通过隐藏层从后向前看，梯度会变得越来越小，说明前面层的学习会显著慢于后面层的学习，所以学习会卡住
，除非梯度变大。

梯度消失的原因：学习率的大小，网络参数的初始化，激活函数的边缘效应等。在深层神经网络中，每一个神经元计算得到的梯度都会传递
给前一层，较浅层的神经元接收到的梯度受到之前所有层梯度的影响。如果计算得到的梯度值非常小，随着层数增多，求出的梯度更新信息
将会以指数形式衰减，就会发生梯度消失。

2、梯度爆炸。在深度网络或循环神经网络（Recurrent Neural Network, RNN）等网络结构中，梯度可在网络更新的过程中不断累积，变
成非常大的梯度，导致网络权重值的大幅更新，使得网络不稳定；在极端情况下，权重值甚至会溢出，变为 [公式] 值，再也无法更新。

3、权重矩阵的退化导致模型的有效自由度减少。

​参数空间中学习的退化速度减慢，导致减少了模型的有效维数，网络的可用自由度对学习中梯度范数的贡献不均衡，随着相乘矩阵的数量
（即网络深度）的增加，矩阵的乘积变得越来越退化。在有硬饱和边界的非线性网络中（例如 ReLU 网络），随着深度增加，退化过程会
变得越来越快。</code></pre><h2 id="二、深度学习和机器学习有什么不同？"><a href="#二、深度学习和机器学习有什么不同？" class="headerlink" title="二、深度学习和机器学习有什么不同？"></a>二、深度学习和机器学习有什么不同？</h2><pre><code>传统的机器学习需要定义一些手工特征，从而有目的的去提取目标信息， 非常依赖任务的特异性以及设计特征的专家经验。而深度学习可
以从大数据中先学习简单的特征，并从其逐渐学习到更为复杂抽象的深层特征，不依赖人工的特征工程。</code></pre><h2 id="三、为什么需要非线性激活函数"><a href="#三、为什么需要非线性激活函数" class="headerlink" title="三、为什么需要非线性激活函数"></a>三、为什么需要非线性激活函数</h2><pre><code>1、激活函数可以把当前特征空间通过一定的线性映射转换到另一个空间，学习和模拟其他复杂类型的数据，例如图像、视频、音频、语音等。

2、假若网络中全部是线性部件，那么线性的组合还是线性，与单独一个线性分类器无异。这样就做不到用非线性来逼近任意函数。

3、使用非线性激活函数 ，以便使网络更加强大，增加它的能力，使它可以学习复杂的事物，复杂的表单数据，以及表示输入输出之间非线性
的复杂的任意函数映射。使用非线性激活函数，能够从输入输出之间生成非线性映射。</code></pre><h2 id="四、激活函数有哪些性质"><a href="#四、激活函数有哪些性质" class="headerlink" title="四、激活函数有哪些性质"></a>四、激活函数有哪些性质</h2><pre><code>1、非线性

2、可微性： 当优化方法是基于梯度的时候，就体现了该性质；

3、单调性： 当激活函数是单调的时候，单层网络能够保证是凸函数；

4、f(x)≈x： 当激活函数满足这个性质的时候，如果参数的初始化是随机的较小值，那么神经网络的训练将会很高效；如果不满足这个性质，
那么就需要详细地去设置初始值；

5、输出值的范围： 当激活函数输出值是有限的时候，基于梯度的优化方法会更加稳定，因为特征的表示受有限权值的影响更显著；当激活
函数的输出是无限的时候，模型的训练会更加高效，不过在这种情况小，一般需要更小的 Learning Rate。</code></pre><h2 id="五、如何选择激活函数"><a href="#五、如何选择激活函数" class="headerlink" title="五、如何选择激活函数"></a>五、如何选择激活函数</h2><pre><code>如果输出是 0、1 值（二分类问题），则输出层选择 sigmoid 函数，然后其它的所有单元都选择 Relu 函数。
如果在隐藏层上不确定使用哪个激活函数，那么通常会使用 Relu 激活函数。有时，也会使用 tanh 激活函数，但 Relu 的一个优点是：
当是负值的时候，导数等于 0。
sigmoid 激活函数：除了输出层是一个二分类问题基本不会用它。
tanh 激活函数：tanh 是非常优秀的，几乎适合所有场合。(双曲正切，tanh(x)=2*sigmoid(2*x)-1)
如果遇到了一些死的神经元，我们可以使用 Leaky ReLU 函数。(给所有负值一个非零斜率)</code></pre><h2 id="六、ReLu激活函数的优点"><a href="#六、ReLu激活函数的优点" class="headerlink" title="六、ReLu激活函数的优点"></a>六、ReLu激活函数的优点</h2><pre><code>1、sigmoid 和 tanh 函数的导数在正负饱和区的梯度都会接近于 0，这会造成梯度弥散，而 Relu 和Leaky ReLu 函数大于 0 部
分都为常数，不会产生梯度弥散现象。

2、在区间变动很大的情况下，ReLu 激活函数的导数或者激活函数的斜率都会远大于 0，在程序实现就是一个 if-else 语句，而 
sigmoid 函数需要进行浮点四则运算，在实践中，使用 ReLu 激活函数神经网络通常会比使用 sigmoid 或者 tanh 激活函数学习的
更快。

3、需注意，Relu 进入负半区的时候，梯度为 0，神经元此时不会训练，产生所谓的稀疏性，而 Leaky ReLu 不会产生这个问题。

稀疏激活性：从信号方面来看，即神经元同时只对输入信号的少部分选择性响应，大量信号被刻意的屏蔽了，这样可以提高学习的精度，
更好更快地提取稀疏特征。当 x&lt;0 时，ReLU 硬饱和，而当 x&gt;0 时，则不存在饱和问题。ReLU 能够在 x&gt;0 时保持梯度不衰减，从而缓解梯
度消失问题。</code></pre><h2 id="七、交叉熵损失函数及其求导推导"><a href="#七、交叉熵损失函数及其求导推导" class="headerlink" title="七、交叉熵损失函数及其求导推导"></a>七、交叉熵损失函数及其求导推导</h2><pre><code>定义：

[公式]

将交叉熵看做是代价函数有两点原因。

​ 第⼀，它是⾮负的， C &gt; 0。可以看出：式子中的求和中的所有独⽴的项都是负数的，因为对数函数的定义域是 (0，1)，并且求和前⾯有
⼀个负号，所以结果是非负。

​ 第⼆，如果对于所有的训练输⼊ x，神经元实际的输出接近⽬标值，那么交叉熵将接近 0。实际输出和⽬标输出之间的差距越⼩，最终的交
叉熵的值就越低了。（这里假设输出结果不是0，就是1，实际分类也是这样的）

交叉熵代价函数有⼀个⽐⼆次代价函数更好的特性就是它避免了学习速度下降的问题。

交叉熵函数关于权重的偏导数：

[公式]

化简后得到：

[公式]

可以看到圈中学习的速度受到 [公式] ，也就是输出中的误差的控制。更⼤的误差，更快的学习速度，特别地，这个代价函数还避免了像在⼆次
代价函数中类似⽅程中 [公式] 导致的学习缓慢。当我们使⽤交叉熵的时候， [公式] 被约掉了，所以我们不再需要关⼼它是不是变得很⼩。这
种约除就是交叉熵带来的特效。</code></pre><h2 id="八、为什么Tanh收敛速度比Sigmoid快？"><a href="#八、为什么Tanh收敛速度比Sigmoid快？" class="headerlink" title="八、为什么Tanh收敛速度比Sigmoid快？"></a>八、为什么Tanh收敛速度比Sigmoid快？</h2><pre><code>[公式]

由上面两个公式可知tanh(x)梯度消失的问题比sigmoid轻，所以Tanh收敛速度比Sigmoid快。</code></pre><h2 id="九、为什么需要-Batch-Size？"><a href="#九、为什么需要-Batch-Size？" class="headerlink" title="九、为什么需要 Batch_Size？"></a>九、为什么需要 Batch_Size？</h2><pre><code>Batch的选择，首先决定的是下降的方向。

如果数据集比较小，可采用全数据集的形式，好处是：

由全数据集确定的方向能够更好地代表样本总体，从而更准确地朝向极值所在的方向。
由于不同权重的梯度值差别巨大，因此选取一个全局的学习率很困难。 Full Batch Learning 可以使用 Rprop 只基于梯度符号并且针对性
单独更新各权值。
对于更大的数据集，假如采用全数据集的形式，坏处是：
随着数据集的海量增长和内存限制，一次性载入所有的数据进来变得越来越不可行。
以 Rprop 的方式迭代，会由于各个 Batch 之间的采样差异性，各次梯度修正值相互抵消，无法修正。这才有了后来 RMSProp 的妥协方案。</code></pre><h2 id="十、Batch-Size-值的选择"><a href="#十、Batch-Size-值的选择" class="headerlink" title="十、Batch_Size 值的选择"></a>十、Batch_Size 值的选择</h2><pre><code>假如每次只训练一个样本，即 Batch_Size = 1。线性神经元在均方误差代价函数的错误面是一个抛物面，横截面是椭圆。对于多层神经元、
非线性网络，在局部依然近似是抛物面。此时，每次修正方向以各自样本的梯度方向修正，横冲直撞各自为政，难以达到收敛。

​ 既然 Batch_Size 为全数据集或者Batch_Size = 1都有各自缺点，可不可以选择一个适中的Batch_Size值呢？

​ 此时，可采用批梯度下降法（Mini-batches Learning）。因为如果数据集足够充分，那么用一半（甚至少得多）的数据训练算出来的梯度
与用全部数据训练出来的梯度是几乎一样的。</code></pre><h2 id="十一、在合理范围内，增大Batch-Size有何好处？"><a href="#十一、在合理范围内，增大Batch-Size有何好处？" class="headerlink" title="十一、在合理范围内，增大Batch_Size有何好处？"></a>十一、在合理范围内，增大Batch_Size有何好处？</h2><pre><code>内存利用率提高了，大矩阵乘法的并行化效率提高。
跑完一次 epoch（全数据集）所需的迭代次数减少，对于相同数据量的处理速度进一步加快。
在一定范围内，一般来说 Batch_Size 越大，其确定的下降方向越准，引起训练震荡越小。
十二、盲目增大 Batch_Size 有何坏处？

内存利用率提高了，但是内存容量可能撑不住了。
跑完一次 epoch（全数据集）所需的迭代次数减少，要想达到相同的精度，其所花费的时间大大增加了，从而对参数的修正也就显得更加缓慢。
Batch_Size 增大到一定程度，其确定的下降方向已经基本不再变化。</code></pre><h2 id="十三、为什么要归一化？"><a href="#十三、为什么要归一化？" class="headerlink" title="十三、为什么要归一化？"></a>十三、为什么要归一化？</h2><pre><code>避免神经元饱和。就是当神经元的激活在接近 0 或者 1 时会饱和，在这些区域，梯度几乎为 0，这样，在反向传播过程中，局部梯度就会接
近 0，这会有效地“杀死”梯度。
保证输出数据中数值小的不被吞食。
加快收敛。数据中常存在奇异样本数据，奇异样本数据存在所引起的网络训练时间增加，并可能引起网络无法收敛，为了避免出现这种情况及
后面数据处理的方便，加快网络学习速度，可以对输入信号进行归一化，使得所有样本的输入信号其均值接近于 0 或与其均方差相比很小。</code></pre><h2 id="十四、为什么归一化能提高求解最优解速度"><a href="#十四、为什么归一化能提高求解最优解速度" class="headerlink" title="十四、为什么归一化能提高求解最优解速度"></a>十四、为什么归一化能提高求解最优解速度</h2><pre><code>上图是代表数据是否归一化的最优解寻解过程（圆圈可以理解为等高线）。左图表示未经归一化操作的寻解过程，右图表示经过归一化后的寻解
过程。
​当使用梯度下降法寻求最优解时，很有可能走“之字型”路线（垂直等高线走），从而导致需要迭代很多次才能收敛；而右图对两个原始特征进行了
归一化，其对应的等高线显得很圆，在梯度下降进行求解时能较快的收敛。

​ 因此如果机器学习模型使用梯度下降法求最优解时，归一化往往非常有必要，否则很难收敛甚至不能收敛。</code></pre><h2 id="十五、归一化有哪些类型？"><a href="#十五、归一化有哪些类型？" class="headerlink" title="十五、归一化有哪些类型？"></a>十五、归一化有哪些类型？</h2><pre><code>1、线性归一化

[公式]

适用范围：比较适用在数值比较集中的情况。

​ 缺点：如果 max 和 min 不稳定，很容易使得归一化结果不稳定，使得后续使用效果也不稳定。

2、标准差归一化

[公式]

经过处理的数据符合标准正态分布，即均值为 0，标准差为 1

3、非线性归一化

适用范围：经常用在数据分化比较大的场景，有些数值很大，有些很小。通过一些数学函数，将原始值进行映射。该方法包括 log、
指数，正切等。

十六、局部响应归一化作用

​ LRN 是一种提高深度学习准确度的技术方法。LRN 一般是在激活、池化函数后的一种方法。

[公式]

其中，

a ：表示卷积层（包括卷积操作和池化操作）后的输出结果，是一个四维数组[batch,height,width,channel]。
batch：批次数(每一批为一张图片)。
height：图片高度。
width：图片宽度。
channel：通道数。可以理解成一批图片中的某一个图片经过卷积操作后输出的神经元个数，或理解为处理后的图片深度。
2. [公式] 表示在这个输出结构中的一个位置 [a,b,c,d] ，可以理解成在某一张图中的某一个通道下的某个高度和某个宽度位置的点，
即第 a 张图的第 d 个通道下的高度为b宽度为c的点。

3. N ：论文公式中的 N 表示通道数 (channel)。

4. a ， n/2 ， k 分别表示函数中的 input,depth_radius,bias。参数 k, n, [公式] 都是超参数，一般设置 [公式]

5. [公式] ： [公式] 叠加的方向是沿着通道方向的，即每个点值的平方和是沿着 a 中的第 3 维 channel 方向的，也就是一个点同
方向的前面 n/2 个通道（最小为第 0 个通道）和后 n/2 个通道（最大为第 d-1 个通道）的点的平方和(共 n+1 个点)。而函数的英
文注解中也说明了把 input 当成是 d 个 3 维的矩阵，说白了就是把 input 的通道数当作 3 维矩阵的个数，叠加的方向也是在通道方向。


​ 在 ALexNet 中，提出了 LRN 层，对局部神经元的活动创建竞争机制，使其中响应比较大对值变得相对更大，并抑制其他反馈较小的
神经元，增强了模型的泛化能力。</code></pre><h2 id="十七、-批归一化（BN）算法的优点"><a href="#十七、-批归一化（BN）算法的优点" class="headerlink" title="十七、 批归一化（BN）算法的优点"></a>十七、 批归一化（BN）算法的优点</h2><pre><code>批归一化（BN）就是在神经网络中间层也进行归一化处理。

优点：

减少了人为选择参数。在某些情况下可以取消 dropout 和 L2 正则项参数,或者采取更小的 L2 正则项约束参数；
减少了对学习率的要求。现在我们可以使用初始很大的学习率或者选择了较小的学习率，算法也能够快速训练收敛；
可以不再使用局部响应归一化。BN 本身就是归一化网络(局部响应归一化在 AlexNet 网络中存在)
破坏原来的数据分布，一定程度上缓解过拟合（防止每批训练中某一个样本经常被挑选到，文献说这个可以提高 1% 的精度）。
减少梯度消失，加快收敛速度，提高训练精度。</code></pre><h2 id="十八、BN算法流程"><a href="#十八、BN算法流程" class="headerlink" title="十八、BN算法流程"></a>十八、BN算法流程</h2><pre><code>下面给出 BN 算法在训练时的过程

输入：上一层输出结果 [公式] ，学习参数 [公式]

算法流程：

1、计算上一层输出数据的均值

[公式]

m是此次训练样本batch的大小

2、计算上一层输出数据的标准差

[公式]

3、归一化处理，得到

[公式]

其中 [公式] 是为了避免分母为 0 而加进去的接近于 0 的很小值

4、重构，对经过上面归一化处理得到的数据进行重构，得到

[公式]

其中， [公式] 为可学习参数。</code></pre><h2 id="十九、Batch-Normalization和Group-Normalization的比较"><a href="#十九、Batch-Normalization和Group-Normalization的比较" class="headerlink" title="十九、Batch Normalization和Group Normalization的比较"></a>十九、Batch Normalization和Group Normalization的比较</h2><p>Batch Normalization：可以让各种网络并行训练。但是维度进行归一化会带来一些问题—–批量统计估算不准确导致<br>批量变小时，BN 的误差会迅速增加。在训练大型网络和将特征转移到计算机视觉任务中（包括检测、分割和视频），内存<br>消耗限制了只能<br>使用小批量的 BN。</p>
<p>Group Normalization：GN将通道分组，并且每组内计算归一化的均值和方差。GN的计算与批量大小无关，并且其准确度在<br>各种批量大小下都很稳定。</p>
<h2 id="二十、Weight-Normalization和Batch-Normalization比较"><a href="#二十、Weight-Normalization和Batch-Normalization比较" class="headerlink" title="二十、Weight Normalization和Batch Normalization比较"></a>二十、Weight Normalization和Batch Normalization比较</h2><pre><code>两者都属于参数重写的方式，只是采用的方式不同。

​Weight Normalization 是对网络权值 W 进行 normalization；Batch Normalization 是对网络某一层输入数据进行
normalization。

Weight Normalization相比Batch Normalization有以下三点优势：

Weight Normalization 通过重写深度学习网络的权重W的方式来加速深度学习网络参数收敛，没有引入 minbatch 的依赖，
适用于 RNN（LSTM）网络（Batch Normalization 不能直接用于RNN，进行 normalization 操作，原因在于：1) RNN 
处理的 Sequence 是变长的；2) RNN 是基于 time step 计算，如果直接使用 Batch Normalization 处理，需要保存
每个 time step 下，mini btach 的均值和方差， 效率低且占内存）。
Batch Normalization 基于一个 mini batch 的数据计算均值和方差，而不是基于整个 Training set 来做，相当于
进行梯度计算式引入噪声。因此，Batch Normalization 不适用于对噪声敏感的强化学习、生成模型
（Generative model：GAN，VAE）使用。相反，Weight Normalization 对通过标量 g 和向量 v 对权重 W 进行重写，
重写向量 v 是固定的，因此，基于 Weight Normalization 的 Normalization 可以看做比
Batch Normalization 引入更少的噪声。
不需要额外的存储空间来保存 mini batch 的均值和方差，同时实现 Weight Normalization 时，对深度学习网络进行
正向信号传播和反向梯度计算带来的额外计算开销也很小。因此，要比采用 Batch Normalization 进行 normalization 
操作时，速度快。 但是 Weight Normalization 不具备
 Batch Normalization 把网络每一层的输出 Y 固定在一个变化范围的作用。因此，采用 Weight Normalization 进行 
 Normalization 时需要特别注意参数初始值的选择。</code></pre><h2 id="二十一、Batch-Normalization在什么时候用比较合适？"><a href="#二十一、Batch-Normalization在什么时候用比较合适？" class="headerlink" title="二十一、Batch Normalization在什么时候用比较合适？"></a>二十一、Batch Normalization在什么时候用比较合适？</h2><pre><code>在CNN中，BN应作用在非线性映射前。在神经网络训练时遇到收敛速度很慢，或梯度爆炸等无法训练的状况时可以尝试BN来解决。
另外，在一般使用情况下也可以加入BN来加快训练速度，提高模型精度。

​BN比较适用的场景是：每个mini-batch比较大，数据分布比较接近。在进行训练之前，要做好充分的shuffle，否则效果会差很多
。另外，由于BN需要在运行过程中统计每个mini-batch的一阶统计量和二阶统计量，因此不适用于动态的网络结构和RNN网络。</code></pre><h2 id="二十二、学习率衰减常用参数有哪些"><a href="#二十二、学习率衰减常用参数有哪些" class="headerlink" title="二十二、学习率衰减常用参数有哪些"></a>二十二、学习率衰减常用参数有哪些</h2><h2 id="二十三、为什么要正则化"><a href="#二十三、为什么要正则化" class="headerlink" title="二十三、为什么要正则化"></a>二十三、为什么要正则化</h2><pre><code>深度学习可能存在过拟合问题-----高方差，有两个解决方法，一个是正则化，另一个是准备更多的数据，这是非常可靠的方法，
但你可能无法时时刻刻准备足够多的训练数据或者获取更多数据的成本很高，但正则化通常有助于避免过拟合或减少你的网络误差。

左图是高偏差，右图是高方差，中间是Just Right。</code></pre><h2 id="二十四、理解dropout正则化"><a href="#二十四、理解dropout正则化" class="headerlink" title="二十四、理解dropout正则化"></a>二十四、理解dropout正则化</h2><pre><code>不要依赖于任何一个特征，因为该单元的输入可能随时被清除，因此该单元通过这种方式传播下去，并为单元的四个输入增加一点权重，
通过传播所有权重，dropout将产生收缩权重的平方范数的效果，和之前讲的L2正则化类似；实施dropout的结果实它会压缩权重，
并完成一些预防过拟合的外层正则化；L2对不同权重的衰减是不同的，它取决于激活函数倍增的大小。</code></pre><h2 id="二十五、dropout率的选择"><a href="#二十五、dropout率的选择" class="headerlink" title="二十五、dropout率的选择"></a>二十五、dropout率的选择</h2><pre><code>1、经过交叉验证，隐含节点dropout率等于0.5的时候效果最好，原因是0.5的时候dropout随机生成的网络结构最多。

2、dropout也可以被用作一种添加噪声的方法，直接对input进行操作、输入层设为更更接近 1 的数。使得输入变化不会太大（0.8）

3、对参数w的训练进行球形限制(max-normalization)，对 dropout 的训练非常有用。

4、使用pretrain方法也可以帮助dropout训练参数，在使用dropout时，要将所有参数都乘以1/p</code></pre><h2 id="二十六、dropout有什么缺点"><a href="#二十六、dropout有什么缺点" class="headerlink" title="二十六、dropout有什么缺点"></a>二十六、dropout有什么缺点</h2><pre><code>dropout一大缺点就是代价函数J不再被明确定义，每次迭代，都会随机移除一些节点，如果再三检查梯度下降的性能，实际上是很难进行复查的。
定义明确的代价函数J每次迭代后都会下降，因为我们所优化的代价函数J实际上并没有明确定义，或者说在某种程度上很难计算，
所以我们失去了调试工具来绘制这样的图片。我通常会关闭dropout函数，将keep-prob的值设为1，运行代码，确保J函数单调递减。
然后打开dropout函数，希望在dropout过程中，代码并未引入bug。我觉得你也可以尝试其它方法，虽然我们并没有关于这些方法性能的数据统计，
但你可以把它们与dropout方法一起使用。</code></pre><h2 id="二十七、如何理解-Internal-Covariate-Shift？"><a href="#二十七、如何理解-Internal-Covariate-Shift？" class="headerlink" title="二十七、如何理解 Internal Covariate Shift？"></a>二十七、如何理解 Internal Covariate Shift？</h2><pre><code>深度神经网络模型的训练为什么会很困难？其中一个重要的原因是，深度神经网络涉及到很多层的叠加，而每一层的参数更新会导致上层
的输入数据分布发生变化，通过层层叠加，高层的输入分布变化会非常剧烈，这就使得高层需要不断去重新适应底层的参数更新。
为了训好模型，我们需要非常谨慎地去设定学习率、初始化权重、以及尽可能细致的参数更新策略。

oogle 将这一现象总结为 Internal Covariate Shift，简称 ICS。 什么是 ICS 呢？

​ 大家都知道在统计机器学习中的一个经典假设是“源空间（source domain）和目标空间（target domain）的数据分布（distribution）
是一致的”。如果不一致，那么就出现了新的机器学习问题，如 transfer learning / domain adaptation 等。而 covariate shift
 就是分布不一致假设之下的一个分支问题，它是指源空间和目标空间的条件概率是一致的，但是其边缘概率不同。

​ 大家细想便会发现，的确，对于神经网络的各层输出，由于它们经过了层内操作作用，其分布显然与各层对应的输入信号分布不同，
而且差异会随着网络深度增大而增大，可是它们所能“指示”的样本标记（label）仍然是不变的，这便符合了covariate shift的定义。
由于是对层间信号的分析，也即是“internal”的来由。

那么ICS会导致什么问题？

简而言之，每个神经元的输入数据不再是“独立同分布”。

其一，上层参数需要不断适应新的输入数据分布，降低学习速度。

其二，下层输入的变化可能趋向于变大或者变小，导致上层落入饱和区，使得学习过早停止。

其三，每层的更新都会影响到其它层，因此每层的参数更新策略需要尽可能的谨慎。</code></pre><h2 id="二十八-为什么说“非饱和式激活函数能解决所谓的梯度消失问题”"><a href="#二十八-为什么说“非饱和式激活函数能解决所谓的梯度消失问题”" class="headerlink" title="二十八. 为什么说“非饱和式激活函数能解决所谓的梯度消失问题”"></a>二十八. 为什么说“非饱和式激活函数能解决所谓的梯度消失问题”</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/02/15/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" data-id="ck6mgun840000z4tk5elr8jdi" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2020/02/07/%E7%88%AC%E8%99%AB%E5%92%8Cb%E7%AB%99%E7%9A%84%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">爬虫和b站的数据分析</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/02/15/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">深度学习基础知识</a>
          </li>
        
          <li>
            <a href="/2020/02/07/%E7%88%AC%E8%99%AB%E5%92%8Cb%E7%AB%99%E7%9A%84%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/">爬虫和b站的数据分析</a>
          </li>
        
          <li>
            <a href="/2020/02/07/python%E9%BB%91%E5%B8%BD%E5%AD%90%E5%AD%A6%E4%B9%A0/">python黑帽子学习</a>
          </li>
        
          <li>
            <a href="/2020/02/04/pytorch%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">pytorch学习记录</a>
          </li>
        
          <li>
            <a href="/2020/01/15/image-match-and-D2-net/">image match and D2-net</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>